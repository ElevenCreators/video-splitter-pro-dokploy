import FetchSplitBridge from "@/components/FetchSplitBridge";
'use client'
import OldUiBridge from "@/components/OldUiBridge";

import Image from 'next/image'
import { useState, useCallback } from 'react'
import { useDropzone } from 'react-dropzone'

interface VideoSegment {
  name: string
  url?: string
  data?: string
  size?: number
}

type JobResponse = { ok: boolean; jobId?: string; error?: string }
type LegacyResponse = { success: boolean; segments?: VideoSegment[]; error?: string }

function isRecord(x: unknown): x is Record<string, unknown> {
  return typeof x === 'object' && x !== null
}
function isJobResponse(x: unknown): x is JobResponse {
  return isRecord(x) && typeof x.ok === 'boolean'
}
function isLegacyResponse(x: unknown): x is LegacyResponse {
  return isRecord(x) && 'success' in x
}
function getErrorFromJson(x: unknown): string | null {
  if (!isRecord(x)) return null
  const v = x['error']
  return typeof v === 'string' ? v : null
}
async function safeJson<T>(res: Response): Promise<T | null> {
  const ct = res.headers.get('content-type') || ''
  if (!ct.includes('application/json')) return null
  try { return (await res.json()) as T } catch { return null }
}

export default function VideoSplitter() {
  const [selectedFile, setSelectedFile] = useState<File | null>(null)
  const [segmentLength, setSegmentLength] = useState(10)
  const [allowReencode, setAllowReencode] = useState(false) // off por defecto
  const [isProcessing, setIsProcessing] = useState(false)
  const [progress, setProgress] = useState(0)
  const [segments, setSegments] = useState<VideoSegment[]>([])
  const [error, setError] = useState<string>('')

  const onDrop = useCallback((acceptedFiles: File[]) => {
    const file = acceptedFiles[0]
    if (file && file.size <= 2 * 1024 * 1024 * 1024) {
      setSelectedFile(file)
      setError('')
      setSegments([])
      setProgress(0)
    } else if (file && file.size > 2 * 1024 * 1024 * 1024) {
      setError('File size exceeds 2GB limit')
    }
  }, [])

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    accept: { 'video/*': ['.mp4', '.avi', '.mov', '.mkv', '.webm'] },
    maxSize: 2 * 1024 * 1024 * 1024,
    multiple: false
  })

  async function pollProgress(jobId: string) {
    setProgress(5)
    const deadline = Date.now() + 2 * 60_000
    await new Promise<void>((resolvePoll, rejectPoll) => {
      const t = setInterval(async () => {
        try {
          if (Date.now() > deadline) {
            clearInterval(t)
            rejectPoll(new Error('Processing timeout'))
            return
          }
          const r = await fetch(`/api/progress?jobId=${encodeURIComponent(jobId)}`)
          if (!r.ok) return
          const data = await safeJson<Record<string, unknown>>(r)
          if (!data || data['ok'] !== true) return
          const job = isRecord(data['job']) ? (data['job'] as Record<string, unknown>) : null
          if (!job) return
          const p = job['progress']
          if (typeof p === 'number') setProgress(p)
          const status = job['status']
          if (status === 'done') {
            clearInterval(t)
            const files = Array.isArray(job['files']) ? (job['files'] as VideoSegment[]) : []
            setSegments(files)
            setProgress(100)
            resolvePoll()
          } else if (status === 'error') {
            clearInterval(t)
            const errMsg = typeof job['error'] === 'string' ? (job['error'] as string) : 'Processing failed'
            rejectPoll(new Error(errMsg))
          }
        } catch { /* siguiente tick */ }
      }, 600)
    })
  }

  const handleSplit = async () => {
    if (!selectedFile) return
    setIsProcessing(true)
    setProgress(0)
    setError('')
    setSegments([])

    try {
      const formData = new FormData()
      formData.append('video', selectedFile)
      formData.append('segmentLength', String(segmentLength))
      formData.append("allowReencode", allowReencode ? '1' : '0')
      formData.append("exactSegments", (allowReencode ? "1" : "0"));
      
const res = await fetch('/api/split-video', { method: 'POST', body: formData });
const result = await res.json();
if (!res.ok || !result?.ok) {
  throw new Error(getErrorFromJson?.(result) ?? result?.error ?? 'Processing failed');
}
setProgress(100);
    } catch (err) {
      setError(err instanceof Error ? err.message : String(err))
      setProgress(0)
    } finally {
      setIsProcessing(false)
    }
  }

  const downloadSegment = async (segment: VideoSegment) => {
    if (segment.url) {
      try {
        const res = await fetch(segment.url)
        if (!res.ok) throw new Error(`HTTP ${res.status}`)
        const blob = await res.blob()
        const url = URL.createObjectURL(blob)
        const a = document.createElement('a')
        a.href = url; a.download = segment.name
        document.body.appendChild(a); a.click(); document.body.removeChild(a)
        URL.revokeObjectURL(url)
        return
      } catch {
        const a = document.createElement('a')
        a.href = segment.url; a.download = segment.name
        document.body.appendChild(a); a.click(); document.body.removeChild(a)
        return
      }
    }
    if (segment.data) {
      const byteChars = atob(segment.data)
      const byteNums = new Array(byteChars.length)
      for (let i = 0; i < byteChars.length; i++) byteNums[i] = byteChars.charCodeAt(i)
      const blob = new Blob([new Uint8Array(byteNums)], { type: 'video/mp4' })
      const url = URL.createObjectURL(blob)
      const a = document.createElement('a')
      a.href = url; a.download = segment.name
      document.body.appendChild(a); a.click(); document.body.removeChild(a)
      URL.revokeObjectURL(url)
    }
  }

  return (
    <div className="flex flex-col justify-center items-center min-h-screen gap-8 bg-[var(--bg)] text-[var(--fg)] px-4">
      {/* Header con logo + tÃƒÂ­tulo nuevo */}
      <div className="text-center flex gap-3 flex-col m-4 p-1 items-center">
        <Image
          src="/logo.svg"
          alt="Video Splitter PRO"
          width={509}
          height={120}
          className="h-14 w-auto md:h-16"
          priority
        />
        <h1 className="font-semibold text-display">Video Splitter PRO</h1>
        <p className="max-w-2xl text-center text-[var(--fg-muted)]">
          Advanced video splitter to cut your videos into precise intervals (2s, 3s, or more). Take your posts to the next level with fast, simple, and seamless video editing.
        </p>
      </div>

      {/* ÃƒÂrea de Drop como Card */}
      <div className="w-full max-w-lg">
        <div
          {...getRootProps()}
          className={`card flex justify-center w-full h-36 px-4 border-dashed cursor-pointer transition-colors duration-300 focus:outline-none ${isDragActive ? 'border-brand-500' : ''}`}
        >
          <input {...getInputProps()} />
          <span className="flex items-center justify-center flex-col">
            <div className="flex items-center">
              <span className="font-medium text-center">
                Drop files to attach, or <span className="text-brand-500 underline font-bold">browse</span>
              </span>
            </div>
            <div><p className="text-xs text-[var(--fg-muted)]">Maximum 2Gb file.</p></div>
            {selectedFile && <div className="mt-2"><p className="text-sm text-green-400 text-center">Ã¢Å“â€œ {selectedFile.name}</p></div>}
          </span>
        </div>
      </div>

      {/* Toggle re-encode con tooltip */}
      <label className="relative flex items-center gap-2 text-sm group select-none">
        <input
          type="checkbox"
          checked={allowReencode}
          onChange={(e) => setAllowReencode(e.target.checked)}
          className="accent-brand-500 h-4 w-4"
        />
        <span className="flex items-center gap-1">
          Force re-encode
          <span
            className="inline-flex items-center justify-center w-4 h-4 rounded-full bg-white/10 text-gray-300 cursor-help"
            title="Activates a second, slower pass that recodes the video if the quick cut fails. Keeps original audio and uses high quality."
            aria-label="MÃƒÂ¡s info"
          >i</span>
        </span>
        <span className="tooltip">
          If fast cutting (without re-encoding) fails or returns 0 segments, enabling this option will attempt a second pass, re-encoding only the video and keeping the original audio to preserve quality. It is slower and uses more CPU.
        </span>
      </label>

      {/* Controles de tiempo */}
      <div className="flex flex-col items-center justify-center gap-3">
        <label className="text-center">Time per clip:</label>
        <div className="flex flex-col items-center gap-3">
          <input
            type="range"
            min="1"
            max="60"
            value={segmentLength}
            onChange={(e) => setSegmentLength(Number(e.target.value))}
            className="range"
          />
          <div className="text-xl px-4 py-2 border border-[var(--border-subtle)] rounded-xl bg-black/20 text-center w-24">
            {segmentLength}s
          </div>
          <div className="flex flex-wrap gap-2 mt-1 justify-center">
            {[2,3,5,10,15,30].map(sec => (
              <button
                key={sec}
                onClick={() => setSegmentLength(sec)}
                className={`chip ${segmentLength===sec ? 'border-brand-500/70 text-white' : ''}`}
                aria-pressed={segmentLength===sec}
              >
                {sec}s
              </button>
            ))}
          </div>
        </div>
      </div>

      {/* BotÃƒÂ³n principal */}
      <button
        onClick={handleSplit}
        disabled={!selectedFile || isProcessing}
        className="btn btn-primary disabled:opacity-50 disabled:cursor-not-allowed"
      >
        {isProcessing ? 'Processing...' : 'Edit'}
      </button>

      {/* Barra de progreso */}
      <div className="flex w-[360px] max-w-full flex-col justify-center items-center">
        <div className="w-full bg-white/10 rounded-full h-2 mb-2">
          <div
            className="bg-brand-500 h-2 rounded-full transition-all duration-300"
            style={{ width: `${progress}%` }}
          />
        </div>
        <p className="p-1 text-sm mt-1">{progress.toFixed(2)}%</p>
      </div>

      {/* Errores */}
      {error && <div className="text-red-400 text-sm max-w-md text-center">{error}</div>}

      {/* Descargas */}
      {segments.length > 0 && (
        <div className="flex flex-col items-center gap-4 mt-2 w-full max-w-lg">
          <h3 className="text-xl font-medium">Download Clips</h3>
          <div className="grid gap-2 w-full">
            {segments.map((segment, idx) => (
              <button
                key={idx}
                onClick={() => downloadSegment(segment)}
                className="btn btn-muted justify-between"
              >
                <span>{segment.name}</span>
                <span className="text-sm text-[var(--fg-muted)]">
                  {segment.size ? (segment.size/(1024*1024)).toFixed(2)+' MB' : 'ready'}
                </span>
              </button>
            ))}
          </div>
        </div>
      )}
    </div>
  )
}






{/* OldUiBridge agregado para auto-descarga */}
<OldUiBridge />


<FetchSplitBridge />
